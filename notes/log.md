# Part III Project Work Log & Notes

## 24/11/16

* Build TESLA on both remote and local machines - it would be good to be able to
  work on both (if ssh is slow or compile times are a problem).
  * Local - ran into a problem when building. Possibly because we require msan
    for something? Can't get it to build for now - try again later if really
    necessary.
  * Remote - seems to build *a lot* faster than on my laptop. Needs libprotobuf
    installed. Possibly better to wait for cluster access rather than mucking
    around in my home directory to try and install it?

* Cluster login - have been added to the appropriate gorups but need to find out
  how to actually log in / install software / etc.

* Reading code and understanding the structure of TESLA
  * Analyzer - tool for walking over TESLA assertions in a program and
    serializing them to protobuf
    * Main entry point in analyzer/tool.cpp parses command line options etc, then
      builds a clang tool and calls out to it
      * Clang tool takes a compilation database and a list of source paths to work
        on
      * Uses a TeslaActionFactory as an argument to the tool - this builds a
        TeslaAction that runs over the source files. Serializes automata usages to
        a protobuf file / string
    * Vistor class walks over automata descriptions and tries to parse them
  * Common - functionality used by multiple parts of TESLA
    * Class that describes the internal automaton / states / transitions between
    * Protocol buffer specification
    * Automatic name generation for internal components
    * Manifest describes the TESLA instrumentation to perform - can be loaded
      from a file (is this the same format that's dumped out by the analysis
      phase / catted together?)
    * Convenience stuff for debugging
  * Instrumenter -  does the work of adding stuff to compiled IR based on the
    analysis phase
    * Adds to the IR based on the actual TESLA assertions that are made
    * Field reference, function calls, struct assignment, assertions etc are
      defined in this part of the code base
    * Translation from actual program events into automata descriptions
  * Tools - the TESLA binary tools that make up the workflow as described in the
    project documentation
    * `cat` - reads all the automata from the filenames passed in, then combines
      them together into a single manifest (doing error checking - for example,
      two automata with the same name but different contents is an error).
    * `print` - just prints out an automata description to the console in a
      bunch of different formats
    * `get-triple` - just a call to the LLVM function that gets the system
      triple.
  * Tests - for automata, instrumentation, integration, parsing, regression
    * Parsing tests put TESLA assertions into a bunch of different C programs
      and use FileCheck to ensure that the assertion grammar is parsed out
      correctly
    * Integration tests build full example programs and ensure that TESLA
      behaves correctly
    * Regression tests cover examples generated from previously found bugs in
      the system
    * Automata covers working on automata protobufs (either written out
      explicitly or generated from C programs) - e.g. that they can be
      concatenated together & resolved properly etc.
    * Instrumentation tests the interaction of the system with LLVM bitcode
      (i.e. that the correct checks are being added to the bitcode files)

* TESLA workflow summary / idea of how data flows through the system
  * Starts from ordinary C programs with no assertions in them
  * Then they are instrumented by adding TESLA assertions to check some
    property of system behaviour
  * A C file with TESLA instrumentation is then *analysed* by the first part of
    the TESLA workflow - the analysis phase produces a `.tesla` file which
    contains an automaton description (these descriptions contain essentially an
    AST of the assertions contained in the program - examples are in the tests
    directory as FileCheck lines).
  * The C file is also compiled as normal into a .ll file using clang once it
    has been analysed.
  * All the .tesla files generated by the analysis phase are combined together
    using the `cat` utility into one manifest.
  * Then, the single combined manifest is used to instrument the compiled LLVM
    bitcode files (giving a set of augmented LLVM bitcode files).
  * The instrumented files can then be compiled using `llc` into a binary as
    normal, with the TESLA functionality included.

## 2/12/2016

* Got set up on the development server by Khilan - managed to get TESLA building
  and installing into a home directory appropriately.
* Manually worked through compiling a program to use TESLA etc.
* Built a somewhat hacky CMakeLists that lets me compile a _simply-structured_ C
  application into a version that is instrumented with TESLA. At some point will
  need to look into how this can actually be done in practice for a larger code
  base! (Ask Jon Anderson?)
* Begun to look into building some very simple TESLA assertions on a small
  program.

## 3/12/2016

* Continued to work on very simple examples learning to use TESLA. Found that
  the documentation is out of date in a number of places:
  * `TESLA_NOW` is replaced by `TESLA_ASSERTION_SITE`
  * `called` seems to have been replaced by `call` but I'm not sure if this is a
    drop-in replacement.
* Notes on using TESLA:
  * `TESLA_ASSERTION_SITE` refers to the point at which the assertion is written
    in the original program (hence why `previously` and `eventually` are written
    the way they are). It can be used to express more complex interleavings of
    temporal properties by having things before / after it as well.
  * `ANY` takes an argument (`int`, `long long`, `ptr` etc.) to represent the
    type of argument being passed to the function call.
  * The `call` function takes a single parameter - the function call as it would
    be written in the program! This is different to `returnfrom`, which takes an
    extra parameter for the return value. Why can't you do
    `call(foo(ANY(int)))`? Ask Jon.

## 5/12/2016

* Did some more digging into why explicit automata descriptions aren't working
  for me. No real answers yet - the symptom is that I have an undefined name in
  the instrumented LLVM code. Something has inserted a global variable for the
  automaton into the code but has not "expanded" it with a definition. Have
  emailed Jon for clarification / help but no answer yet. The next place to look
  is probably trying to find out what is meant to replace the global variable.

## 15/12/2016

* Still no reply from Jon. Should get Robert to prod him. Looking into why I get
  these linker errors with a much-simplified example. Seems that the
  `tesla_update_state` function is getting called with `my_auto` as an argument,
  which is a global variable in the LLVM IR. This means (probably) that
  something isn't actually populating this global variable with a real value.
  Dig though code and find out where?
* When we end up calling `ExternAutomatonDescrip` to get a global variable,
  the first time we call, there isn't a variable ready. The second time, there
  is and we get it.
* Looks like `BuildAutomatonDescription` is doing what we want but it isn't
  getting called - it is responsible for getting rid of extern specified global
  variables and replacing them with things that actually have an initializer!
* It seems to be called in two separate places in Assertion.cpp - how do these
  different places get triggered? Actually only in one location for the version
  of TESLA I have on my machine (why is this different??) This was different
  because I was building against CTSRD TESLA rather than CADETS TESLA and there
  was some difference in the code for newer commits.
* The path that gets to where we want to be is returning early because there are
  no assertions in the module. How do I add an assertion to the module?
* `TESLA_STRUCT_AUTOMATON` is dead - the actual syntax is to use the automaton
  just like a function call (for example, `eventually(my_auto(a))`)
* Usage: you can't go arbitrarily far down the call stack using `TESLA_WITHIN` -
  it seems to be only within the current function that it's usable. 
