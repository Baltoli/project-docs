# Generic Automaton Analysis

So far we have a way of analysing a very specific automaton - it's tied
to the name and semantics of this automaton, and can only be used as
such. The logical next step is to look at how we might begin to analyse
automata more generically (i.e. with no presupposed knowledge of how any
particular automaton works).

## Overview

A TESLA automata essentially specifies an LTL expression that relates
the occurrence of program events to each other in time within a bounding
function. Our goal for static analysis is to prove this assertion (or a
part thereof) at compile time, and then to use this proof or partial
proof to remove some of the instrumentation code generated by TESLA.

There are a number of event types that TESLA is capable of recognising
and instrumenting:

* **Function Calls / Returns**: we can recognise when a given function
  is called or returns, with particular arguments or return value.
* **Field Assignment**: we can instrument assignment of a particular
  value to a structure field.
* **Assertion Site**: when an assertion is made, the source location is
  noted and can be referenced as an event.

We can then make logical connectives between these events - for example,
stating that a certain sequence of events occurs or that an event
happens at some point in the future.

All of these events are bounded - an assertion always has a start and
end event (commonly a function call or return). The assertion is only
considered within these bounds. One way of looking at this is that an
assertion names a sequence of events that starts with the start bound,
includes the assertion events, and ends with the end bound:

```
TESLA_WITHIN(g, eventually(f(x, y) = 0));
    
    |
  becomes
    |
    v

call(g)
    |
    v
assertion site
    |
    v
f(x,y) = 0
    |
    v
returnfrom(g)
```

This is then compiled into an automaton that moves between states
according to these events being observed (e.g. calling `g` puts the
automaton into a state where it expects to see the assertion site event
next).

## Existing Static Analysis

The analysis that I have implemented so far is one that detects usage of
one particular automaton, asserts a number of properties about the IR in
the module it's being run on, then deletes the usage of the automaton if
the necessary properties are satisfied.

## New Approach

A more generic approach will need to transform automata in a manifest,
rather than deleting usages (in most cases at least). This means that we
probably need some shared code that can apply transformations to
manifests (we already know how stuff can be copied from an existing
manifest).

## Inter / Intraprocedural Analysis

Some analyses are reasonably easy to perform inside a single function,
but become harder to do when considered across function boundaries.
Considering the differences here will be important for some analyses.
