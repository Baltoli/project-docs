# Formalising TESLA

A big component of the work I've done on TESLA is coming up with a (so far
informal) model of what a TESLA assertion really *means*. To do the writeup I
should work out an actual formalism for the assertions.

In a sense this formalism is working backwards - it starts from the
implementation of TESLA (which defines the behaviour), and then works out a
formalism from there.

## TESLA Assertions

There is a mapping from TESLA assertions onto automata of some kind. This is
implicit in the way the system is implemented, the original code has parts that
work on constructing automata and converting between various formats (NFA, DFA,
etc.).

Ideally I will be able to give a more abstract description of how these automata
are built and composed (using the implementation as a reference).

The original paper gives a program-level overview of how an assertion is
constructed, but we want to give a "syntax tree" level formulation. Can then
give an idealised compositional mapping from these constructs to automata.
There's also the issue of mapping from the TESLA macros to the lower-level
assertion language.

Points to note when looking into the automata generated by TESLA:
* Failure conditions - how do we formalise the idea that some events are
  acceptable and others not?
* Sequence repetition - to keep things as finite state machines, repeated states
  are simply encoded as copies. Means that the size of an automaton can depend
  on the number of repetitions it has (and as a consequence, the size of the
  binary as well!).

So at a high level, TESLA instrumentation of a program consists of a set of
named assertions together with a "root" assertion that specifies the "entry
point" to the instrumentation.

Assertions can be one of the several possible types (null, boolean, sequence
etc.), with recursive subautomata as appropriate. May also have attributes
(boolean operator if 'or' wasn't the only one, sequence reps).

Then for each polymorphic variant, define a finite state machine that can be
*composed* to build the full state machine. I think the easiest way of doing
this is to build NFAs so that we can use epsilon transitions where necessary.

## Events

Because TESLA assertions are relevant both at runtime and compile time, I need
to come up with an abstraction that unifies the two environments. I think some
notion of *event* is what we're looking for. An executing program generates
events as it executes (this is what instrumentation generates in the program).
For example, making function calls or reaching assertion sites during an
execution would generate the corresponding events.

The TESLA automaton is the same whether we're at runtime or compile time, and so
what the static analysis (in full genericity) is trying to do is prove what
sequences of events can be generated by a program, fully at compile time.

Give a single formulation of events that can cover both the static and the
dynamic cases.

Events can be:
* Function calls, possibly with values for parameters specified.
* Function returns, possibly with the return value specified
* Assertion sites
* Assignments to a structure field (dynamic only)

Then the program can be viewed as a graph of these events over which traces can
be generated (in a data and path-insensitive way). Maybe worth mentioning how
graph and trace generation could be achieved to improve the algorithm.

## Algorithms

The algorithms that I've written to do static checking on TESLA are probably not
optimal. Working out a proper formalism for TESLA means that the algorithms can
be described in more common terminology, build on literature etc.

### Event Graph & Trace Generation

The event graph for a module is generated by ...

Could we aggressively inline every function call? We already actually do this to
an extent, but not "properly". Maybe worth investigating. Benab et. al. paper on
applicability of the polyhedral model mentions that this type of analysis is
difficult / impossible to do interprocedurally, so they inline everything. Lots
of useful stuff in this paper about how to normalise and represent dynamic
control flow. Describes a method for transforming general dynamic ocntrol flow
into an abstract representation.

### Initial Model Checking

The first part of the model checker works by generating finite bounded traces
over the event graph extracted from the IR. These traces are restricted to be
those that "terminate" (i.e. have the assertion start and end events), and those
that cycle (do not terminate, but contain a cycle of events at the end).

Then, assertion sequences are generated from the TESLA assertion. This is also
trace generation, but over the finite state machine generated from the initial
assertion. The event trace is checked to see whether *there exists* a trace
through the state machine for that trace (need better vocabulary when writing
this up for real!).

A better algorithm would be to construct an actual FSM for the model, then do a
graph search through it (avoids overgeneration, but is equivalent I think).

This detects event graphs that cannot possibly match the model, but leave some
that are incorrect because of return value constraints.

### Return Value Checking

Interesting / relevant paper: PAGAI. The tool implemented in this paper does
sort of the same thing as what we do to compute inferences (though extended to
allow for polyhedral operations, SMT solving etc.). The interface exposed by the
tool is that C programs can be annotated with assert / assume, that are then
translated into reachability checks. Mentions that `mem2reg` is an important
pass to use (by translating memory accesses into scalar variables), and that
it's OK to treat other memory accesses as nondeterministic choice.

The analysis is limited to an intraprocedural form in PAGAI, but uses inlining
to get around this (same idea as the polyhedral stuff - this kind of control
flow checking is very hard to do interprocedurally, so inlining aggressively
tends to be the best option).

## Differences to Existing Approaches

Will also need to do more reading and highlight the differences between checking
TESLA assertions and how existing approaches do model checking.
