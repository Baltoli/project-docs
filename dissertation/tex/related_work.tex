In this chapter I provide an overview of related work in areas relevant
to this project, along with a summary of how my work on TESLA
contributes new ideas and developments.

\section{Program Verification} \label{sec:bounded-model-checking}

There is a great deal of prior research related to program verification using
temporal logic assertions and model checking. In this section I give a summary
of important work in this area that has influenced parts of my work on static
analysis for TESLA.

\subsection{Bounded Model Checking}

In this section I give a sumamry of previous work in the area of bounded
model checking, with particular emphasis on where it has been applied to
check C programs. I also note key differences between these previous
works and my implementation of a TESLA model checker---namely the style
of assertion supported, and the use of non-symbolic checking in my
implementation.

\subsubsection{BMC}

\textcite{biere_symbolic_1999} introduce the concept of bounded model
checking, building upon the earlier idea of \emph{symbolic} model
checking due to \textcite{mcmillan_symbolic_1992} while removing the
need to construct BDDs\footnote{Binary Decision Diagrams}. Their
implementation of a bounded model checker, BMC, used the state
description language SMV\footnote{In fact, SMV describes both the state
structure and the assertions made of it.} described by
\citeauthor{mcmillan_symbolic_1992} and was able to show significant
performance improvements over previous work.

At the heart of symbolic model checking is the idea of counterexample
generation---if a state is found to satisfy the negation of a formula,
then that state is a counterexample for the original formula. The model
checking process can then be undertaken as a satisfiability problem.
Bounded model checking builds on this idea by searching for
counterexamples with an upper bound on the allowable length. This means
that the counterexamples discovered are of minimal length, and are
discovered faster.

While the implementation strategies and analysis goals of BMC and my
model checker are quite different (BMC is a symbolic model checker for
SMV, my model checker is a non-symbolic model checker for TESLA
assertions embedded in C programs), the strategy of searching for
counterexamples using an iterative-deepening method is derived in part
from the original work on bounded model checking.

\subsubsection{CBMC}

\citeauthor{clarke_behavioral_2003}'s CBMC \cite{clarke_behavioral_2003}
is perhaps the first instance of bounded model checking being applied to
C programs (rather than to a state description language such as SMV).
The focus of the CBMC tool was to allow for C programs to be written as
executable specifications for synchronous Verilog hardware designs
without prohibiting the use of any C programming construct (use of
pointers, memory allocations and recursive calls are all permitted).

Ideas from previous work on BMC together with the new idea of
\emph{unwinding assertions}\footnote{An assertion that captures the idea
that a loop has been unrolled \textquote{enough} times.} allowed C
programs and assertions to be translated into boolean formulae, which
could then be checked using a SAT solver.

Although CBMC is an example of model checking being applied to C
programs, the assertions that can be checked are only local assertions
(albeit with some temporal information available by supplying the value
of Verilog signals to the C program). In this sense, the scope and
target of TESLA assertions is different to those of CBMC---TESLA
assertions are written to verify the behaviour of a program, while CBMC
uses a C program with assertions to verify that a hardware
implementation is behaviourally equivalent to that program. It is worth noting
that the CBMC technique of modelling hardware with a C program can be
generalised to any system expressible as a C program with an appropriately sized
state space.

\subsubsection{LLBMC}

CBMC operates at the level of C source code (the translation to a
boolean formula is specified using syntactic transformations).
\textcite{merz_llbmc:_2012} identified a potential avenue for
improvement upon this model---their LLBMC operates on LLVM
\cite{lattner_llvm:_2002} intermediate representation. The benefits of
this approach include broader language support, assistance from compiler
optimisations for code simplification, and an improved memory model. The
assertions supported by LLBMC are a combination of user-supplied local
assertions, and a set of built-in safety assertions (arithmetic
overflow, memory safety etc.).

Empirically, LLBMC represents an improvement over previous work in the
area it is compared to---it is able to detect more assertion failures in
a larger set of programs than both CBMC and an extended implementation
thereof (ESBMC \cite{cordeiro_smt-based_2009}).

The use of a compiler intermediate representation to simplify model
checking is similar in concept to TESLA (modulo the differences between
symbolic and non-symbolic model checking).

\subsubsection{Context-bounded LTL Checking}

More recent work by \textcite{morse_context-bounded_2011,
morse_model_2015-1} uses bounded model checking to verify more complex
LTL assertions made of a C program. Their approach involves the
translation of an LTL formula into a B\"uchi automaton, which is then
itself converted to C code and woven into the program to be checked.

This approach is reminiscent of TESLA instrumentation, but has some key
differences. The automaton code here has its own thread of execution
rather than being inlined as TESLA instrumentation is, and instead of
producing a modified executable that exhibits runtime failures on
assertion violations, the combined program is checked statically using
ESMBC to check for violations.

Although the development of this work was partly contemporaneous with
the initial work on TESLA, and the implementation strategies were
similar in some respects, the LTL assertions checkable by this system
are closer to those asserted by CBMC than to those asserted by TESLA.

\subsection{Other Approaches}

While there has been a great deal of work derived from BMC on verifying
systems software, there are also other approaches that do not share the
same lineage.

\subsubsection{MOPS}

\textcite{anderson_tesla:_2014} identify MOPS \cite{chen_mops:_2002} as being
partially similar to TESLA in concept. The primary goal of MOPS is to discover
potential vulnerabilities of C programs operating in a Unix environment (where
security properties may have whole papers dedicated to explaining their
subtleties, as is the case with \mintinline{c}{setuid} \cite{chen_setuid_2002}).
The authors were able to use MOPS to discover a number of security
vulnerabilities in well-known open-source software.

Properties in MOPS are expressed as finite state automata, with accepting states
representing an execution on which an unsafe event has occurred. The expression
of TESLA assertions is similar in concept to this, but with extensions to check
function arguments and return values. MOPS assertions can express slightly
different properties than TESLA assertions can (and vice versa). MOPS can assert
properties such as \textquote{a call to \mintinline{c}{f} is immediately
followed by a call to \mintinline{c}{g}}, while TESLA can assert that
\textquote{if execution reaches this program point, \mintinline{c}{f} was
previously called}. Broadly, however, the concepts are similar.

The primary advantage of the TESLA model checker compared to MOPS is the
inclusion of assertion site events for considering control flow only on certain
paths, and the ability to check a subset of the program's data flow.

\subsubsection{KLEE}

KLEE \cite{cadar_klee:_2008} is a system for symbolic execution of programs in
order to automatically generate tests or prove assertions. It differs from other
approaches described here as it is does not perform model checking---instead, it
generates constraints that must hold for a program point to be reachable, then
solves the constraints to generate test inputs to the program. KLEE is
implemented as an interpreter for LLVM bitcode.

The primary motivation for this implementation style is to increase the
source-level coverage of a program's test suite. This means exploring every
possible execution path, an approach that TESLA sought explicitly to avoid (by
using automata bounds and assertion site events). However, some of the ideas
present in KLEE are relevant to the TESLA model checker. In particular, the idea
of solving constraints on program values could be used to generalise the return
value constraint algorithm I described in \autoref{sec:rvc}.

\section{SMT} \label{sec:smt}

In this section I give a brief overview of the theory of SMT methods, as well as
a summary of important work in the area.

\subsection{Background}

As its name suggests, the study of satisfiability modulo theories (SMT) is
founded in boolean satisfiability. The decision problem SAT was the first such
problem to be proven to be NP-complete \cite{cook_complexity_1971}---its
statement can be given concisely as \textquote{Does there exist a consistent
assignment of truth values to the variables in a boolean formula such that the
formula is satisfied?}. SAT exhibits the useful property of self-reducibility,
meaning that any algorithm that solves the decision problem can be used to find
a satisfying assigment.

Many problems can be easily reduced to SAT (formally, any problem in NP can be
reduced to SAT in polynomial time, and informally, its structure makes it a good
choice for encoding some domain-specific problems). However, many other problems
are stated with respect to a background theory such as integer arithmetic or
finite arrays. The key idea of SMT problems is to allow for a \emph{background
theory} to be combined with a satisfiability problem.

\textcite[ch. 12]{biere_handbook_2009} provide a formal definition of SMT
problems, as well as several commonly-used background theories. For the purposes
of this report, only a basic definition is required.

\subsubsection{Terminology}

A \emph{background theory} is a collection of axioms that allow for
interpretation of the symbols in a formula. For example, the background theory
of integer arithmetic provides the standard interpretations of symbols such as $
+, -, \times, 0 $ etc. A different background theory such as that of finite
bit-vectors may interpret these symbols differently (for example, \ $+$ could be
defined to wrap on overflow).

\emph{Uninterpreted functions} are the building blocks of SMT instances. No
meaning is associated with these functions when an SMT problem is specified,
only that they have a particular \emph{sort}\footnote{Informally, sorts can be
understood as ``types'' in a particular problem. Examples are the sorts of
integers, booleans, and functions with particular domain and range.}. An SMT
solver may assign interpretations to these functions in order to satisfy the
instance constraints.

\subsubsection{Tools and Standards}

A great deal of research and engineering work is invested in the use of SMT
tools. Two of the most commonly used solver implementations are Z3
\cite{de_moura_z3:_2008} and CVC4 \cite{barrett_cvc4_2011}, but there are
numerous others with individual strengths and weaknesses. As well as
implementations, there exist standards such as SMT-LIB \cite{BarFT-SMTLIB} that
specify textual input and output formats for SMT solvers. Standardisation in
this way allows for competitive benchmarking of solver performance (the primary
venue for this is SMT-COMP \cite{CDW14}).

\subsection{Related Work}

SMT solvers are a low-level tool---using them to solve a domain-specific problem
involves translating the problem into a formulae in a particular theory. Because
of this flexibility, SMT solvers have been used to solve a large number of
disparate problems. For example, Microsoft list 58 publications related to
Z3\footnote{\url{https://github.com/Z3Prover/z3/wiki/Publications}} that span
areas as diverse as cloud computing, verification of real-time systems, and
functional programming.

In this section I give a summary of related work in the area of program analysis
and verification, one of the primary motivating applications of SMT solvers.

\textcite{dahlweid_vcc:_2009} provide VCC, a tool for proving partial
correctness of C programs using annotations that describe invariants on data
structures. These annotations are converted to an intermediate representation,
then to an SMT problem to be verified. The annotations supported by VCC are
somewhat different to TESLA assertions---they specify invariant rather than
temporal properties. VCC was used successfully to verify the implementation of
the Microsoft Hyper-V kernel.

The interactive theorem prover Isabelle \cite{paulson_isabelle:_2000} supports
the use of SMT solvers to generate proofs. These proofs are written in a
higher-level formalism that can then be extracted into verified functional
programs. This approach is conceptually very different to TESLA and similar
``systems'' tools---rather than starting from a program to be verified, the
proof itself is the primary object of interest.

Recent work has emerged on the use of SMT solvers as tools for performing
``superoptimisation'' (Optgen \cite{buchwald_optgen:_2015} and
Souper \cite{regehr_souper_2017} are two examples). This approach aims to
discover potential optimisations that are left unimplemented by a compiler.
Souper translates LLVM IR into SMT formulae, but is otherwise conceptually
unrelated to TESLA.

PAGAI \cite{henry_pagai:_2012} uses SMT solvers to implement analyses based on
abstract interpretation. For example, it can be used to discover invariants that
hold at points in the control flow graphs, and to prove properties based on
assertion reachability. The methods used in PAGAI to map LLVM IR onto an SMT
problem are more sophisticated that those I describe in \autoref{sec:rvc}---for
example, PAGAI implements an arithmetic simplification method based on parallel
assignments that allows for stronger invariants to be proved.
