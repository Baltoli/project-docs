In this chapter I give a summary of previous work related to TESLA on which this
project builds, a short overview of the practical issues associated with using
TESLA and an introduction to the TESLA assertion language. I also provide a
guide to the TESLA-specific terminology used throughout the rest of this report.

\section{Temporal Assertions}

Before describing TESLA in detail, it is worth giving a motivating example of
why it is useful. The simplest possible explanation is that it allows the
programmer to make assertions about events that occur in the past and future
execution of a program (rather than just about the current program state).

\autoref{lst:mutex-simple} shows a C function for acquiring a mutual exclusion
lock.\footnote{In a simple usage scenario, and modulo a correct implementation
of atomic compare-and-swap (\mintinline{c}{CAS}).} For a program's usage of the
lock to be \emph{safe}, it must eventually release the lock. However, within
\mintinline{c}{lock_acquire}, there is no way of asserting this property using
standard C constructs---the call that releases the lock could be logically
separated from the call that acquires it (for example, a library function could
acquire the lock then depend on user code releasing it).

TESLA allows for \emph{temporal} properties to be expressed.
\autoref{lst:mutex-better} shows the same lock acquisition function, but with a
TESLA assertion enforcing the safety property. The property is in the same
source location as the function it applies to, and is independent of where calls
to \mintinline{c}{lock_acquire} and \mintinline{c}{lock_release} are made. The
remainder of this chapter describes TESLA assertions and the associated tooling
in more detail.

\begin{figure}
  \begin{minted}{c}
void lock_acquire(lock_t *lock) {
  return CAS(&lock->locked, false, true);
}
  \end{minted}
  \caption{Lock acquisition without safety propery enforced}
  \label{lst:mutex-simple}
\end{figure}

\begin{figure}
  \begin{minted}{c}
void lock_acquire(lock_t *lock) {
  TESLA_WITHIN(main, eventually(
    lock_release(lock)
  ));
  return CAS(&lock->locked, false, true);
}
  \end{minted}
  \caption{Lock acquisition with safety property enforced using TESLA}
  \label{lst:mutex-better}
\end{figure}

\section{Summary of Existing Work}

\begin{displaycquote}[p. 1]{anderson_tesla:_2014}
TESLA is a description, analysis, and validation tool that allows systems
  programmers to describe expected temporal behaviour in low-level languages
  such as C.
\end{displaycquote}

\textcite{anderson_tesla:_2014} introduce TESLA as a tool for validating
safety\footnote{A \emph{safety} property asserts that ``bad things'' do not
happen during the execution of a program, while a \emph{liveness} property
asserts that ``good things'' do eventually happen
\cite{lamport_proving_1977,alpern_defining_1984}.} properties of systems code.
These safety properties are written inline with the program they describe, and
are checked at runtime by dynamic instrumentation code (added during an extra
compilation phase).

In \cite{anderson_tesla:_2014}, the authors detail their experiences using TESLA
to perform complex debugging on large, well-known systems software. These
efforts were successful---a security vulnerability in OpenSSL was discovered and
fixed, along with an elusive bug in the GNUStep graphics library. Additionally,
they detail the overhead associated with using TESLA (at compile- and run-time)
and identify static analysis as a possible future direction of research.

The work in this report builds on the original implementation of TESLA---the
primary components of the original work are a parser for TESLA assertions, an
instrumentation system that adds code to the programs in questions, and a
runtime support library. While my work has involved some minor modifications to
the original implementation, the majority of it is newly developed. Any
references to dynamic or runtime components are part of the original TESLA
implementation, while any references to static analysis or model checking are
part of my contributions. I explicitly note places where I have modified the
original TESLA implementation.

\section{Programming with TESLA}

In this section I give a brief overview of how TESLA is used in practice
to instrument programs.

\subsection{Terminology} \label{sec:terminology}

Programmers may add \emph{assertions} to their code to ensure its
correctness---these are logical statements predicated on data in the current
scope. TESLA assertions are similar in concept, but express temporal relations
between \emph{program events}. Temporal assertions require a \emph{bounding
interval}---a pair of start and end events that specifies where initialisation
and cleanup code should be placed.

Each TESLA assertion defines an \emph{automaton}, and a collection of
these automata is referred to as a \emph{manifest} when serialised to
disk. An \emph{assertion site} is the source location where an assertion
was originally written, and a \emph{function event} is a call to or
return from a function.

\subsection{Build Process} \label{sec:build-tesla}

Using TESLA to instrument a program requires that its build process is modified
to produce TESLA-specific intermediate products. \autoref{fig:c-compilation}
shows the traditional compilation model for C programs;
\autoref{fig:c-tesla-compilation} shows the additional steps required by TESLA.

\afterpage{%
\clearpage\clearpage
\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    \node [msourcefile] (source1) {\texttt{.c}};

    \node [msourcefile, right=3em of source1] (obj1) {\texttt{.o}};

    \draw[-latex] (source1.east) -- (obj1.west);

    \node [right=3em of obj1] (exe) {executable};

    \draw[-latex] (obj1.east) -- (exe.west);
  \end{tikzpicture}
  \caption{The traditional C compilation model}
  \label{fig:c-compilation}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \node [msourcefile] (source1) {\texttt{.c}};

    \node [right=5em of source1] (mid) {};
    \node [msourcefile, above=1em of mid] (bc1) {\texttt{.bc}};
    \node [msourcefile, below=1em of mid] (tesla1) {\texttt{.tesla}};

    \draw[-latex] (source1.east) to [out=0,in=180] (bc1.west);
    \draw[-latex] (source1.east) to [out=0,in=180] (tesla1.west);

    \node [sourcefile,right=3em of tesla1] (tesla2) {\texttt{.manifest}};
    \node [sourcefile] at (bc1 -| tesla2) (bc2) {\texttt{.bc}};

    \draw[-latex] (bc1.east) to [out=0,in=180] (bc2.west);
    \draw[-latex] (tesla1.east) to [out=0,in=180] (tesla2.west);

    \node [sourcefile,right=12em of mid] (instr) {\texttt{.instr.bc}};

    \draw[-latex] (bc2.east) to [out=0,in=180] (instr.west);
    \draw[-latex] (tesla2.east) to [out=0,in=180] (instr.west);

    \node [right=3em of instr] (exe) {executable};

    \draw[-latex] (instr) -- (exe);
  \end{tikzpicture}
  \caption{The C compilation model with TESLA integrated}
  \label{fig:c-tesla-compilation}
\end{figure}
}

A \texttt{.bc} file contains LLVM intermediate code, and a \texttt{.tesla} file
contains a binary or textual representation of the TESLA assertion manifest.

The TESLA toolchain is used together with the Clang / LLVM compiler
infrastructure to generate these intermediate artifacts. A brief summary of the
individual TESLA tools used is:

\begin{description}
  \item[\texttt{analyze}] parses TESLA assertions from a C source file and
    outputs them to a \texttt{.tesla} manifest file.
  \item[\texttt{instrument}] adds instrumentation code to a program in LLVM IR
    format based on the data in a TESLA manifest file.
  \item[\texttt{cat}] combines several TESLA assertion manifests together,
    checking for consistency and eliminating redundant definitions.
\end{description}

Using these tools as described in the context of an automated build system
imposes some configuration overhead on the programmer. However, it is
possible to develop generic TESLA build scripts or to modify a project's
existing build system to generate TESLA intermediate products.

\subsection{Writing Assertions}

TESLA assertions are written using a set of preprocessor macros that expand to
calls to instrumentation hook functions. These functions have no definition, and
are only used as a way to store information in the IR. Calls to them are removed
by the instrumenter.

An example of the TESLA macros being written inline with a program is
given in \autoref{lst:tesla-example}.

\begin{figure}
  \begin{minted}{c}
int main(void)
{
  TESLA_WITHIN(main,
    eventually(
      call(some_function(ANY(ptr))),
      other_function(ANY(int)) == 0
    )
  );

  int x;
  some_function(&x);

  return other_function(x);
}
  \end{minted}
  \caption{Example of TESLA macros being used to write an assertion}
  \label{lst:tesla-example}
\end{figure}

\section{The TESLA Assertion Language} \label{sec:assertions}

Assertions specify temporal relations between \emph{program events} as defined
in \autoref{sec:terminology} (function calls, assertion sites etc.).

The basic temporal relation expressible in the assertion language is
sequencing---an assertion that events occur in a particular order. Disjunction
of assertions is also expressible. Assertions must include a reference to an
assertion site event---this reference is implicit in \autoref{lst:tesla-example}
through the \mintinline{c}{eventually} macro, which states that the sequence of
events listed take place after the assertion site.

Automata can be written \emph{explicitly} to allow for composition (similar to
defining a function in an ordinary programming language).
\autoref{lst:tesla-explicit} shows an example of this style.

\begin{figure}
  \begin{minted}{c}
automaton(name_of_auto, struct arg_type *s) {
  some_function(s) == 0;
  call(function1) || call(function2);
  s->field = 4;
  tesla_done;
}
  \end{minted}
  \caption{Example of an explicit TESLA automaton}
  \label{lst:tesla-explicit}
\end{figure}
