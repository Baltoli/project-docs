In this chapter I give a summary of previous work related to TESLA on which this
project builds, a short overview of the practical issues associated with using
TESLA and an introduction to the TESLA assertion language used throughout this
report. I also give an overview of the theoretical background to important
techniques used in the implementation of this project.

\section{Summary of Existing Work}

\begin{displaycquote}[p. 1]{anderson_tesla:_2014}
TESLA is a description, analysis, and validation tool that allows systems
  programmers to describe expected temporal behaviour in low-level languages
  such as C.
\end{displaycquote}

\textcite{anderson_tesla:_2014} introduce TESLA as a tool for validating
safety\footnote{A \emph{safety} property asserts that ``bad things'' do not
happen during the execution of a program, while a \emph{liveness} property
asserts that ``good things'' do eventually happen
\cite{lamport_proving_1977,alpern_defining_1984}.} properties of systems code.
These safety properties are written inline to the program they describe, and are
checked at runtime by means of an extended compilation process that adds
instrumentation to the intermediate representation of a program.

In \cite{anderson_tesla:_2014}, the authors detail their experiences
using TESLA to perform complex debugging on large pieces of systems
software. These efforts were successful---a security vulnerability in
OpenSSL was discovered and fixed, along with an elusive bug in the
GNUStep graphics library. Additionally, they detail the overhead
associated with using TESLA (at compile time and run time) and identify
static analysis as a possible future direction of research.

The work in this report builds on the original implementation of
TESLA---the primary components of this are a parser for TESLA
assertions, an instrumentation system that adds code to the programs in
questions, and a runtime support library. While my work has involved
some minor modifications to the original implementation, the majority of
it is newly developed. The distinction between original and new work
should therefore be clear.

\section{Programming with TESLA}

In this section I give a brief overview of how TESLA is used in practice
to instrument programs.

\subsection{Terminology}

Programmers may add \emph{assertions} to their code to ensure its
correctness---these are logical statements predicated on the current
scope. TESLA assertions are similar in concept, but allow for
\emph{temporal} properties to be asserted as well. Temporal assertions require a
\emph{bounding interval}---a pair of start and end events that specifies where
initialisation and cleanup code should be placed.

Each TESLA assertion defines an \emph{automaton}, and a collection of
these automata is referred to as a \emph{manifest} when serialised to
disk. An \emph{assertion site} is the source location where an assertion
was originally written, and a \emph{function event} is a call to or
return from a function.

\subsection{Build Process} \label{sec:build-tesla}

Using TESLA to instrument a program requires that the build process is
modified to produce TESLA-specific intermediate products.
\autoref{fig:c-compilation} shows the traditional compilation model for
C programs; \autoref{fig:c-tesla-compilation} shows the additional
steps required by TESLA.

\afterpage{%
\clearpage\clearpage
\begin{figure}[t]
  \centering
  \begin{tikzpicture}
    \node [msourcefile] (source1) {\texttt{.c}};

    \node [msourcefile, right=3em of source1] (obj1) {\texttt{.o}};

    \draw[-latex] (source1.east) -- (obj1.west);

    \node [right=3em of obj1] (exe) {executable};

    \draw[-latex] (obj1.east) -- (exe.west);
  \end{tikzpicture}
  \caption{The traditional C compilation model}
  \label{fig:c-compilation}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \node [msourcefile] (source1) {\texttt{.c}};

    \node [right=5em of source1] (mid) {};
    \node [msourcefile, above=1em of mid] (bc1) {\texttt{.bc}};
    \node [msourcefile, below=1em of mid] (tesla1) {\texttt{.tesla}};

    \draw[-latex] (source1.east) to [out=0,in=180] (bc1.west);
    \draw[-latex] (source1.east) to [out=0,in=180] (tesla1.west);

    \node [sourcefile,right=3em of tesla1] (tesla2) {\texttt{.manifest}};
    \node [sourcefile] at (bc1 -| tesla2) (bc2) {\texttt{.bc}};

    \draw[-latex] (bc1.east) to [out=0,in=180] (bc2.west);
    \draw[-latex] (tesla1.east) to [out=0,in=180] (tesla2.west);

    \node [sourcefile,right=12em of mid] (instr) {\texttt{.instr.bc}};

    \draw[-latex] (bc2.east) to [out=0,in=180] (instr.west);
    \draw[-latex] (tesla2.east) to [out=0,in=180] (instr.west);

    \node [right=3em of instr] (exe) {executable};

    \draw[-latex] (instr) -- (exe);
  \end{tikzpicture}
  \caption{The C compilation model with TESLA integrated}
  \label{fig:c-tesla-compilation}
\end{figure}
}

A \texttt{.bc} file contains LLVM intermediate code in its stable binary format,
and a \texttt{.tesla} file contains a binary representation of the TESLA
assertion manifest.

The TESLA toolchain is used together with the Clang / LLVM compiler
infrastructure to generate these intermediate artifacts. A brief summary of the
individual TESLA tools used is:

\begin{description}
  \item[\texttt{analyze}] parses TESLA assertions from a C source file and
    outputs them to a \texttt{.tesla} manifest file.
  \item[\texttt{instrument}] adds instrumentation code to a program in LLVM IR
    format based on the data in a TESLA manifest file.
  \item[\texttt{cat}] combines several TESLA assertion manifests together,
    checking for consistency and eliminating redundant definitions.
\end{description}

Using these tools as described in the context of an automated build system
imposes some configuration overhead on the programmer. However, it is
possible to develop generic TESLA build scripts or to modify a project's
existing build system to generate TESLA intermediate products.

\subsection{Writing Assertions}

Once a project has been set up to build against TESLA, assertions can be
written using the included set of preprocessor macros. These macros
provide a convenient wrapper interface over the TESLA marker functions.
Marker functions have no definitions---their only use is to appear as
the target of a function call that will later be replaced with
instrumentation code.

An example of the TESLA macros being written inline with a program is
given in \autoref{lst:tesla-example}.

\begin{figure}
  \begin{minted}{c}
int main(void)
{
  TESLA_WITHIN(main,
    eventually(
      call(some_function(ANY(ptr))),
      other_function(ANY(int)) == 0
    )
  );

  int x;
  some_function(&x);

  return other_function(x);
}
  \end{minted}
  \caption{Example of TESLA macros being used to write an assertion}
  \label{lst:tesla-example}
\end{figure}

\section{The TESLA Assertion Language} \label{sec:assertions}

Assertions specify temporal relations between \emph{program events},
within a specified bounding interval. These events are function calls or
returns (possibly with arguments and / or return values specified),
assertion sites or structure field assignments. An assertion site event
occurs when program execution reaches the location where the assertion
was originally written in the program. A bounding interval is specified
by two events and defines where initialisation and cleanup code should
be inserted.

The basic temporal relation expressible in the assertion language is
sequencing---an assertion that events occur in a particular order.
Disjunction of events is also expressible, allowing for multiple
choices. Assertions must include a reference to an assertion site
event---this reference is implicit in \autoref{lst:tesla-example}
through the \mintinline{c}{eventually} macro, which states that the
sequence of events listed take place after the assertion site.

Automata can be written \emph{explicitly} to allow for composition
(similar to defining a function in an ordinary program).
\autoref{lst:tesla-explicit} shows an example of this style.

\begin{figure}
  \begin{minted}{c}
automaton(name_of_auto, struct arg_type *s) {
  some_function(s) == 0;
  call(function1) || call(function2);
  s->field = 4;
  tesla_done;
}
  \end{minted}
  \caption{Example of an explicit TESLA automaton}
  \label{lst:tesla-explicit}
\end{figure}
