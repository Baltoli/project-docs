The tools available for programmers to assert the correctness of their code are
almost always \emph{instantaneous}---assertions can be made about the current
state of the program, but not about previous or future states. As a result,
\emph{temporal} properties of programs are often checked informally or not at
all.

TESLA \cite{anderson_tesla:_2014} provides systems programmers with a means of
mechanically checking temporal properties of their code by modifying the
compilation process to insert instrumentation into programs. This approach
proved successful---a number of bugs in large open-source libraries were
identified and fixed with the help of temporal assertions. However, using TESLA
imposes significant runtime performance overhead on a program (up to $7\times$
on some workloads), and so its usage so far has been restricted to debugging
scenarios where this overhead is acceptable.

In this report I propose the use of \emph{static analysis} for optimisation of
TESLA assertions---if an assertion can be proved correct at compile time, then
its instrumentation code can be omitted from the program. This has a number of
benefits. For example, the program is likely to be smaller and faster than if
the instrumentation were included, and potential counterexamples to assertions
can be given to the programmer as a useful debugging tool in their own right.

To demonstrate the utility of static analysis, I provide an implementation of
TESLA-instrumented mutual exclusion locks along with benchmarks that show
performance overhead of more than $10\%$ for a single assertion. Then, I
demonstrate a set of highly specialised program analyses that can be used to
prove the correctness of these assertions in particular. 

Generalising from these analyses, I contribute a translation of TESLA
assertions to finite state automata that formalises components of the original
work. I use this translation to describe an algorithm for checking the
correctness of a program with respect to a checkable subset of TESLA assertions.
Finally, I give an implementation of this algorithm that can be easily
integrated into the existing TESLA toolchain.

To evaluate the model checker, I investigate how TESLA can be applied to the
internal implementation of TCP in the LWIP library \cite{dunkels_design_2001}
(with emphasis on the potential of statically analysing this instrumentation).
Then, motivated by the difficulties encountered during this process, I describe
a general framework for using TESLA to instrument library interface code. This
builds on previous TESLA work, but represents a much more general approach than
has previously been achieved.

I apply this technique to an existing application written using the LWIP APIs,
adding TESLA assertions to validate the application's usage of TCP protocol
code. Architectural benchmarks show performance overhead of up to $40\%$ from
five TESLA assertions. This overhead can be completely eliminated by the model
checker, demonstrating that it is a valuable contribution towards greater
applicability of TESLA.
